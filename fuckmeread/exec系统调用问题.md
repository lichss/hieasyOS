### 两天白干
创建exec系统调用的最后一步出问题，
新的页表已经创建好，通过cr3装在也完成了，但是当exec创建的新进程开始执行的时候，报页错误。

在报错的地方打断点，观察cpu所有寄存器的值是否正常。
只发现了一个明显的错误，esp值和预期不符。
最开始发现esp的值设置的不太对，这对应了sys_exec中设置栈帧的方法错误，修复了之后esp的值和预期一样。但这不是页错误的原因。执行代码还是报页错误。
其余寄存器装载值都和预期一致，除了eip，但这也是正常的，总不可能编译出来的源码占用内存空间都正好一样。
然后尝试观察内存映射(qemu info mem)
得到的映射关系和预期的不完全一致，但我认为这应该是正常的。可能是再分配页的时候多了一页少了一页。可能某些数据我设置的缓存空间大了或小了。
但暂时也没别的思路了，去查memory.c中的逻辑有无问题。
重点查了分配页的函数和对每个内存也进行映射的函数。还是没发现问题。
还有就是如果这一块回出问题那应该早就出问题了，内存部分已经经过好几个提交前的测试了，实在是不觉得会有问题。
最后无意中发现问题出在了pte表项的pde表项的联合定义...
实在是很难相信是这部分出了问题，原因就是内存部分实际上经过好几个提交测试了。查错的重点都放在最近一两次提交中更新的内容。
具体错误原因如下：
``` C
/*错误的pte表项结构定义*/
typedef union _pte_t{
    uint32_t v;
    struct {
        uint32_t present : 1;
        uint32_t write_disable : 1;
        uint32_t user_mode_acc : 1;
        uint32_t write_through : 1;
        uint32_t cache_disable : 1;
        uint32_t accessed : 1;
        uint32_t dirty : 1;
        uint32_t pat : 1;
        uint32_t : 3;
        uint32_t phy_page_addr: 20;
    };
}pte_t;

/*正确的定义，*/
typedef union _pte_t{
    uint32_t v;
    struct {
        uint32_t present : 1;
        uint32_t write_disable : 1;
        uint32_t user_mode_acc : 1;
        uint32_t write_through : 1;
        uint32_t cache_disable : 1;
        uint32_t accessed : 1;
        uint32_t dirty : 1;
        uint32_t pat : 1;
        uint32_t global ：1;    /*错误的定义中少了这一项*/
        uint32_t : 3;
        uint32_t phy_page_addr: 20;
    };
}pte_t;

```
在之前的版本，也就是错误的定义中表项中少了一个`uint32_t gobal ： 1;` 因为使用这一项的情况本身也很少，所以之前一直没发现少了一项定义。
所以这样就导致pte的联合定义中有一项可能是未定义的，但关键最搞的是，由于是联合体定义，当直接给吧pte表项当做32位数赋值的时候是正确的，但如果是按照pte的结构去赋值有会因为定也错误触发未定义行为。而且还有一个很搞的地方，由于是物理地址，物理地址的最后一位是0的可能性也很高，如果编译器给的填充数正好是0，他就很可能是正常运行的。运气不好，编译器给的填充数不是0，是其他随机数那就会触发问题。

而且而且，虚拟地址是正确的，物理地址是错误的，这种问题很难在软件层面上观察到，观察cpu的寄存器页也发下不了这个异常。

这是开始操作系统这个实践以来耗时最久，最难找的错误。

第一次的fork调用也没问题
就是这只好的ip地址去访问的时候出问题
刚开始思路是以为exec调用接口有问题,逐行查 发现了几个无关痛痒的问题,一直解决不了。
后来去一个个排查exec的所有涉及到的进程操作，还是没发现问题
